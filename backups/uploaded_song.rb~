require 'id3lib'
require 'digest/sha1'
require 'net/http'


class UploadedSong < ActiveRecord::Base
  # attr_accessible :title, :body
  has_many :cut_songs
  belongs_to :user
  #================================#
  #Layer 1 extraction on metadata
  #reads directly from mp3 ID3 Tags 
  #================================#
  def read_metadata
    # extract all meta information from ID3lib
    tag = ID3Lib::Tag.new(self.path)
    # save all details 
    self.title = tag.frame_text(:TIT2)
    self.artist = tag.frame_text(:TPE1)
    self.album = tag.frame_text(:TALB)
    self.track = tag.frame_text(:TRCK)
    self.year = tag.frame_text(:TYER)
    self.comment1 = tag.frame_text(:COMM)
    self.comment2 =  ""
    self.genre = tag.frame_text(:TCON)
    
    # naming the album_art with <hash>.mp3 to <hash>.jpg
    image_type = tag.frame(:APIC)[:mimetype].split('/')[1]
    art = self.path.split('.')[0]+'.'+image_type
    # APIC stands for album art . Read the binary data and save it
    File.open(art,'wb') {|f| f.write tag.frame(:APIC)[:data] }
    self.album_art = art
    self.save
  end
 
  #======================================#
  # Hash the song with its content - SHA1
  # Save it in public/audios file 
  #======================================#
  def save_song(upload)
    # get the name of file from http
    name =  upload['datafile'].original_filename
    
    # set song directory
    self.name = name
    directory = "public/audios"
    
    # create the file path 
    path = File.join(directory, name)
    
    # write the file temporarily
    File.open(path, "wb") { |f| f.write(upload['datafile'].read) }
    
    # get size of a file
    self.size = File.stat(path).size
    
    # generate hash for a given file
    file_hash = Digest::SHA1.hexdigest(path).to_s
    
    # Write the temp file to a new hash file and and delete the temp file
    hash = File.join(directory, file_hash +'.mp3')
    File.open(hash, "wb") { |f| f.write(File.open(path, "r").read) }
    
    # delete the file after saving it in a hash file
    File.delete(path)
    
    # path has file name appended with hash
    self.path = hash
    
    # have file_hash seperately for future purpose
    self.file_hash= file_hash
    
    # set default the album art still it is processed by DJ
    previous_art = nil
    previous_song = UploadedSong.
    find_by_sql("select * from uploaded_songs where album_art like '%#{file_hash}%'")
    
    unless previous_song.empty?
      previous_art = previous_song[0].album_art
    end
     
    unless previous_art.nil? 
      self.album_art = previous_art 
    else
       self.album_art = 'audios/default.png' 
    end
    self.save
    # delay metadata extraction to later stage using delayed_job
    self.delay.read_metadata
    return self
  end
 
  #====================================#
  # create a child from it original song
  # call actual cut method - mp3splt  
  #====================================#
  def cut(start_duration,end_duration)
    new_cut = self.cut_songs.new
    # making cut as delayed_job
    new_cut.delay.mp3splt(start_duration,end_duration)
    return new_cut
  end
  
  #========================================#
  # calculate the FINGERPRINT using fpcalc 
  # fpcalc pasted in /usr/bin for conveneince
  # save the finger print in song table itself
  #=========================================#
  def set_fingerprint
    result = `fpcalc "#{self.path}"`
    self.duration = result.split('DURATION=')[1].split('FINGERPRINT=')[0].chomp!
    self.finger_print = result.split('FINGERPRINT=')[1].chomp!
    self.save
  end
 
  #======================================#
  # Layer 2 extraction on metadata
  # Lookup the acoustid for exact metadata
  # TODO:
  # Parse the resultant string and update the ActiveRecord
  #=======================================#
  def get_ws_info
    uri = URI("http://api.acoustid.org/v2/lookup?client=8XaBELgH&meta=recordings+releasegroups+compress&duration=#{self.duration}&fingerprint=#{self.finger_print}")
    result = Net::HTTP.get(uri) # => String
    puts result
  end
end
